import ij.*;import java.io.*;import java.util.ArrayList;import java.util.Iterator;import java.text.DecimalFormat;//Definicao da classe e todos os metodos responsaveis por calcular os momentos de Zernikepublic class Zernike {	/*	Metodo responsável por calcular os momentos de Zernike, recebendo a ordem do	polinomio e a imagem que sera processada	*/		public static String calculaZernike(ImageAccess input, int ordem) {			//declaracao das variaveis necessarias		int nx;					// largura da imagem		int ny;					// altura da imagem		int aux;				//auxiliar em calculos		int maior;				//maior valor do tamanho da imagem		int menor;				//menor valor do tamanho da imagem		double vnl;				// polinômio de zernike		double rnl;				// polinômio radial ortogonal		double value, momento;			// variavéis para brilho do pixel e momento		ArrayList<Double> brilhos;		// brilho dos pixels		ArrayList<Double> teta;			// angulos dos pixels		ArrayList<Double> r;			// raios dos pixels		ImageAccess output;			//imagem de saída		DecimalFormat df;				// formatador de casa decimais		String vetor = "";				// vetor de características		// inicialização de variáveis		nx = input.getWidth();						ny = input.getHeight();						r = new ArrayList<Double>();				teta = new ArrayList<Double>();				brilhos = new ArrayList<Double>();			df = new DecimalFormat("0.##");				/*	Preparação da imagem para se tornar quadrada */		//Se numero colunas maior que numero de linhas			if(ny > nx){			maior = ny;			menor = nx;						aux = ny - nx;			aux = (int)aux/2;									output = new ImageAccess(nx,(ny-(aux*2)));				for(int x = aux; x < maior-aux; x++) {						for(int y = 0; y < menor; y++) {						value = input.getPixel(x,y);						output.putPixel(x-aux,y,value);						brilhos.add(value);		//adiciona ao ArrayList o valor do pixel				}			}		}		//Se numero linhas maior que numero de colunas		else if(ny < nx){			maior = nx;			menor = ny;			aux = nx - ny;			aux = (int)aux/2;				output = new ImageAccess((nx-(aux*2)),ny);				for(int x = 0; x < menor; x++) {						for(int y = aux; y < maior-aux; y++) {						value = input.getPixel(x,y);						output.putPixel(x,y-aux,value);						brilhos.add(value);		//adiciona ao ArrayList o valor do pixel				}			}		}    	else{	//Se imagem já for quadrada			output = new ImageAccess(nx,ny);					output = input;								for(int x = 0; x < nx; x++) {							for(int y = 0; y < ny; y++) {						value = input.getPixel(x,y);						brilhos.add(value);			//adiciona ao ArrayList o valor do pixel				}			}		}		// inicio dos ArrayLists necessarios para o restante do calculo		teta = calculaAngulo(output);			//Chamada do método para cálculo dos Angulos 		r = calculaRaio(output);			//Chamada do método para cálculo dos Raios 		for(int n = 0; n <= ordem; n++) { 		//inicia loop para cada N			for(int l = 0; l <= n; l++) {		//inicia loop para cada L					int l_abs = Math.abs(l); 	//módulo de L				//Calcula os momentos para n-l = par e l<=n				if(((n - l_abs)%2 == 0) && (l_abs <= n)) {							momento  = 0.0;								vnl = 0.0;								rnl = 0.0;											//loop que acessa de forma sincrona todos os ArrayLists necessarios para o calculo das integrais					for(int i = 0; i < r.size(); i++){						// chamada de método de calculo do polinomio radial ortogonal (Rnl)						rnl = calculaPolinomioRadial(n,l_abs,r.get(i));																		// chamada de método calculo do polinomio de Zernike (Znl)						vnl = Math.hypot(rnl * Math.cos(l * teta.get(i)), rnl * Math.sin(l * teta.get(i)));						// calculo do momento de Zernique (Anl)												momento = momento + vnl * brilhos.get(i) * r.get(i);					}										// calculo do momento resultante com as integrais calculadas (Anl)					momento = momento * ((n + 1) / Math.PI);											//preparacao do vetor resultante para a imagem com nl estabelecidos					vetor = vetor + String.valueOf(df.format(momento)) + " ";						}			}		}		return vetor;	//retorno dos momentos resultantes	} // fim do metodo calculaZernike	/*	Metodo responsavel por calcular o raio de cada pixel da imagem output recebida e repassar os resultados no formato ArrayList */	private static ArrayList<Double> calculaRaio(ImageAccess output) {		int dx;		int dy;		dx = output.getWidth();									dy = output.getHeight();								ArrayList<Double> raios;								raios = new ArrayList<Double>();							for(int x = 0; x < dx; x++) {				for(int y = 0; y < dy; y++) {						raios.add(Math.hypot(dx, dy));		//calculo do valor da hipotenusa resultante dos pontos				}			}		return raios;												}//fim do metodo calculaRaio	/*	Metodo que calcula o angulo de cada pixel da imagem output recebida e repassa o resultado no formato ArrayList */	private static ArrayList<Double> calculaAngulo(ImageAccess output) {		int dx;		int dy;		dx = output.getWidth();									dy = output.getHeight();								ArrayList<Double> angulos;								angulos = new ArrayList<Double>();							for(int x = 0; x < dx; x++) {				for(int y = 0; y < dy; y++) {						angulos.add(Math.atan(dy/dx));		//calculo do valor do arcotangente resultante de dy/dx				}			}		return angulos;										}//fim do metodo calculaAngulo		/* Metodo que calcula o fatorial de um numero inteiro recebido de forma recursiva*/		private static int fatorial(int numero) {			if(numero == 0) {								   		     	return 1;									   		 	} else {		        return (numero * fatorial(numero - 1));				    }		}// fim do metodo fatorial			/*	Metodo que calcula o polinomio radial baseando em n, l e r e retorna o valor em forma de double	*/		private static double calculaPolinomioRadial(int n, int l, double r) {			double resultado = 0.0;							int lim = (n - l)/2;				//limite de execucao da formula			for(int s = 0; s <= lim; s++) {						resultado = resultado + (double)(Math.pow((-1), s) 				* (fatorial(n - s) / (fatorial(s) * fatorial(((n + l)/2) - s) * fatorial(((n - l)/2) - s)))				* Math.pow(r, n - (2 * s)));			}//fors			return resultado;									}// fim do metodo calculaPolinomioRadial} // fim da classe Zernike