import ij.*;import ij.gui.*;import ij.process.*;import java.awt.*;import java.awt.event.*;import java.util.*;import ij.text.TextWindow;import javax.swing.*;import java.io.*;import java.lang.*;import ij.io.Opener;import ij.io.OpenDialog; /** * Plugin of ImageJ: Zernike * * Este plugin calcula o vetor de características de uma imagem de referência * e de uma dada base de imagens de busca, armazenando seus vetores em um arquivo, * onde cada linha conté o nome do arquivo da imagem, seguido do seu vetor de  * características. * * @version 1.0 */	public class Zernike_ extends JDialog implements ActionListener {	private ImagePlus imp;			// referência para imagem de entrada	private ImageAccess image;		// imagem processada	private int ordem = 0;			// ordem do polinômio	//acesso à imagem    public static ImageAccess input;	private File file;	private FileWriter fw;	private PrintWriter pw;	private GridBagLayout layout;	private GridBagConstraints constraint;	private TextField txtOrdemPol = new TextField("3", 5);	private JButton bnClose;	private JButton bnRun;	private String vetorBanco;	private String vetorRef;	private String[] list;	private String dir;	private String titleRef;	// título da imagem de referência	/**	* Construtor.	*/	public Zernike_() {		super(new Frame(), "Momentos de Zernike");				if (IJ.versionLessThan("1.21a")) {			return;		}					doDialog();	}		/**	* Run.	*/	public void run() {		imp = WindowManager.getCurrentImage();		// verifica se há imagem aberta		if (imp == null) {			IJ.error("Não há nenhuma imagem aberta!");			return;		}		// obtém o título do documento		titleRef = imp.getTitle().split("\\.")[0];	// remove a extensão				// transforma ImagePlus em ImageAccess		image = new ImageAccess(imp.getProcessor());		// objeto para o arquivo		file = new File("MomentsZernike.txt");		try {			file.createNewFile();		// cria um novo arquivo			fw = new FileWriter(file);			pw = new PrintWriter(fw);		} catch(IOException e) {			System.out.println("Problemas ao criar o arquivo.");		}				vetorRef = Zernike.calculaZernike(image, ordem);		pw.write(titleRef + " [ ");		pw.write(vetorRef + "]\n\n");		pw.flush();  //força que todas as strings que, por ventura, ainda estejam no buffer sejam gravadas no arquivo				// pasta com a base de imagens de busca		OpenDialog od = new OpenDialog("Abrindo pasta de busca...");		if(od.getFileName() == null) {			return;		}		dir = od.getDirectory();		calculaMomentos(dir);		IJ.showMessage("Resultado gerado!");							ImageWindow win = imp.getWindow();				} // fim método run	/**	* Calcula os momentos de Zernike de todas as imagens de um diretório especifico,	* salvando essas informações em um arquivo txt.	*	* @param dir		nome do diretório de busca	**/	public void calculaMomentos(String dir){		// trata o diretório, e adiciona as imagens contidas nele numa lista		if (!dir.endsWith(File.separator)) {            dir += File.separator;		}        list = new File(dir).list();  // lista de arquivos do diretório         if (list == null) {			IJ.showMessage("Nenhuma imagem encontrada!");			return;		// se não houver nenhuma imagem no diretório escolhido		}		// Calcula os momentos para cada imagem contida no diretório        for(int i = 0; i < (list.length); i++) {            File f = new File(dir + list[i]);			if(!list[i].equals("Thumbs.db")) { // Thumbs.db encontrado no sistema operacional Windows				if(!f.isDirectory()) {					ImagePlus image = new Opener().openImage(dir, list[i]); // abre imagem i da lista					input = new ImageAccess(image.getProcessor().convertToByte(false));					String title = image.getTitle().split("\\.")[0];	// remove a extensão					if((image != null) && (!title.equals(titleRef))) {						vetorBanco = Zernike.calculaZernike(input, ordem);						pw.write(title + " [ ");						pw.write(vetorBanco + "]\n");						pw.flush();					}				}			}		}	} // fim do método calculaMomentos	/**	* Constrói a caixa de diálogo.	*/	private void doDialog() {		// layout		layout = new GridBagLayout();		constraint = new GridBagConstraints();		// botões		bnClose = new JButton("Fechar");		bnRun   = new JButton("Executar");				// botões do painel		JPanel pnButtons = new JPanel();		pnButtons.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 0));				pnButtons.add(bnClose);		pnButtons.add(bnRun);				// parâmetros do painel		JPanel pnParameters = new JPanel();		pnParameters.setLayout(layout);		addComponent(pnParameters, 1, 0, 1, 1, 5, new JLabel("Insira a ordem: "));		addComponent(pnParameters, 1, 1, 1, 1, 5, txtOrdemPol);				// adiciona Listeners		bnClose.addActionListener(this);		bnRun.addActionListener(this);						JPanel pnMain = new JPanel();		pnMain.setLayout(layout);		addComponent(pnMain, 0, 0, 1, 1, 10, pnParameters);		addComponent(pnMain, 1, 0, 1, 1, 10, pnButtons);				// construindo painel principal		this.getContentPane().add(pnMain);		pack();		setResizable(false);		GUI.center(this);		setVisible(true);		IJ.wait(250);	} // fim método doDialog		/**	* Adiciona um componente no painel no norte da célula.	*/	final private void addComponent(					final JPanel pn,					final int row, final int col, 					final int width, final int height, 					final int space,					final Component comp)	{		constraint.gridx = col;		constraint.gridy = row;		constraint.gridwidth = width;		constraint.gridheight = height;		constraint.anchor = GridBagConstraints.NORTHWEST;		constraint.insets = new Insets(space, space, space, space);		constraint.weightx = IJ.isMacintosh()?90:100;		constraint.fill = constraint.HORIZONTAL;		layout.setConstraints(comp, constraint);		pn.add(comp);	}	/**	* Implementa o actionPerformed para o ActionListener.	*/    @Override	public synchronized  void actionPerformed(ActionEvent e) {		if (e.getSource() == bnClose) {			dispose();						try {								fw.close();				pw.close();						} catch(FileNotFoundException  e1) {				System.out.println("O arquivo não foi encontrado.");			} catch(IOException e2) {				System.out.println("Problemas na leitura/escrita do arquivo.");			}		} else if (e.getSource() == bnRun) {			ordem = getIntegerValue(txtOrdemPol, 0, 3, 1000);			run();					}		notify();	}				/**	* Obtém um valor double de um TextField entre um valor mínimo e máximo.	*/	private int getIntegerValue(TextField text, int mini, int defaut, int maxi) {				int d;		try {			d = (new Integer(text.getText())).intValue();			if(d < mini) {				text.setText("" + mini);			}			if(d > maxi) {				text.setText("" + maxi);			}		} catch (Exception e) {			if(e instanceof NumberFormatException) {				text.setText("" + defaut);			}		}		d = (new Integer(text.getText())).intValue();		return d;	}} // fim da classe